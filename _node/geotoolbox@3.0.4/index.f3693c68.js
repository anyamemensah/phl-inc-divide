import e from"../geos-wasm@1.2.1/index.18242ca2.js";import{geojsonToGeosGeom,geosGeomToGeojson}from"../geos-wasm@1.2.1/helpers.484cfef9.js";import{geoArea,geoCircle,geoBounds,geoEquirectangularRaw,geoPath,geoIdentity,geoCentroid,geoTransform,geoContains,geoStream,geoAzimuthalEquidistant}from"../d3-geo@3.1.1/index.75f0ca91.js";import{topology}from"../topojson-server@3.0.1/index.cee28c81.js";import{merge,feature,quantize,mesh,neighbors}from"../topojson-client@3.1.0/index.a55369bb.js";import*as j$1 from"../d3-array@3.2.4/index.f89e3560.js";import{deviation,variance,mean,median,mode,max,min,sum,ascending,descending}from"../d3-array@3.2.4/index.f89e3560.js";import{autoType}from"../d3-dsv@3.0.1/index.48418e2e.js";import{simplify,quantile,presimplify}from"../topojson-simplify@3.0.3/index.9e8dd3cc.js";import{geoStitch}from"../d3-geo-projection@4.0.0/index.c33f0ac5.js";import{parse}from"../geojson-precision@1.0.0/index.2393cf2c.js";function o$4($){return $!==null&&$!==""&&typeof $!="boolean"&&isFinite($)}function i$7($,N){const k=$.features.map(M=>o$4(M.properties[N]));return k.filter(M=>M===!0).length>k.length/2}function u$7($,N){const k=$.map(M=>o$4(M[N]));return k.filter(M=>M===!0).length>k.length/2}function a$3($){return typeof $=="object"&&["Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon"].includes($?.type)&&Array.isArray($?.coordinates)&&$?.coordinates.length!==0?!!$.coordinates.every(N=>N==null||Number.isNaN(N)):!0}function y$3($){return new Function(`return (${$})`)()}function f$6($){return!!(!Array.isArray($)&&typeof $=="object"&&$?.type=="FeatureCollection"&&Array.isArray($?.features)&&$?.features[0]?.hasOwnProperty("type")&&$?.features[0]?.hasOwnProperty("properties")&&$?.features[0]?.hasOwnProperty("geometry"))}function p$6($){return!!(Array.isArray($)&&!Array.isArray($[0])&&$.length>0&&typeof $[0]=="object")}function l$5($){return Array.from(new Set($.features.filter(N=>N.geometry!==null).map(N=>N.geometry.type)))}function c$5($){return!!(!Array.isArray($)&&$?.type=="FeatureCollection"&&Array.isArray($?.features)&&$?.features[0]?.hasOwnProperty("type")&&$?.features[0]?.hasOwnProperty("properties")&&$?.features[0]?.hasOwnProperty("geometry"))}function A$1($){return $?.type=="Topology"&&!Array.isArray($)}function h$5($){return!!(Array.isArray($)&&$.length>0&&$[0]?.hasOwnProperty("type")&&$[0]?.hasOwnProperty("properties")&&$[0]?.hasOwnProperty("geometry"))}function g$6($){return!!(typeof $=="object"&&!Array.isArray($)&&$!==null&&$?.hasOwnProperty("type")&&$?.hasOwnProperty("properties")&&$?.hasOwnProperty("geometry"))}function w$4($){return!!(Array.isArray($)&&$.length>0&&$[0]?.hasOwnProperty("type")&&$[0]?.hasOwnProperty("coordinates"))}function P$1($){return!!(typeof $=="object"&&!Array.isArray($)&&$!==null&&$?.hasOwnProperty("type")&&$?.hasOwnProperty("coordinates"))}function b$4($){return!!(Array.isArray($)&&!Array.isArray($[0])&&$.length>0&&typeof $[0]=="object")}function O$3($){return!!(Array.isArray($)&&$[0].length==2&&Array.isArray($[0])&&typeof $[0][0]!="object"&&typeof $[0][1]!="object")}function m$4($){return!!(Array.isArray($)&&$.length==2&&o$4($[0])&&o$4($[1]))}async function t$1($,{func:N=M=>M,mutate:k=!1}={}){let M=$;return f$6(M)?(k||(M=JSON.parse(JSON.stringify($))),M.features=await Promise.all(M.features.map(L=>Promise.resolve(N(L))))):p$6(M)&&(M=await Promise.all(M.map(L=>Promise.resolve(N(L)))),k&&$.splice(0,$.length,...M)),M}function w$3($,{maxrows:N=null}={}){let k,M=f$6($);M?k=$.features.map(K=>Object.assign({GEOMETRY:K?.geometry?.type},K.properties)):k=$;let L=document.createElement("table"),R=document.createElement("thead"),I=document.createElement("tr");const U=Object.keys(k[0]);U.forEach((K,Z)=>{const te=k.map(se=>se[K]),ne=te.length;console.log(te);const oe=te.filter(se=>![""," ","  ",void 0,NaN,null,1/0,-1/0].includes(se)).length;let ee=document.createElement("th");ee.innerHTML=K+`<span style='font-size: 0.7em; font-style: italic ; font-weight: normal; color: #808080'><br/>${oe}/${ne}</span>`,ee.style.cursor="pointer",ee.style.backgroundColor="white",ee.style.color="#444",ee.style.padding="10px",ee.style.textAlign="left",ee.style.position="sticky",ee.style.top="0",ee.style.zIndex="1",ee.style.borderBottom="2px solid #444",ee.style.fontSize="1em";let re=!0;ee.addEventListener("click",()=>{re=!re,Y(Z,re)}),I.appendChild(ee)}),R.appendChild(I),L.appendChild(R);let H=document.createElement("tbody");const W=N?k.slice(0,N):k;function Q(K){H.innerHTML="",K.forEach((Z,te)=>{let ne=document.createElement("tr");ne.style.backgroundColor=te%2===0?"#f9f9f9":"#fff",ne.style.fontSize="0.9em",U.forEach((oe,ee)=>{let re=document.createElement("td");re.textContent=Z[oe],re.style.padding="5px",re.style.borderBottom="1px solid #ddd",re.style.textAlign="left",M&&(re.style.backgroundColor=ee===0?"#444":void 0,re.style.color=ee===0?"white":void 0),ne.appendChild(re)}),H.appendChild(ne)})}function Y(K,Z){W.sort((te,ne)=>{let oe=te[U[K]],ee=ne[U[K]];return!isNaN(parseFloat(oe))&&!isNaN(parseFloat(ee))?Z?oe-ee:ee-oe:Z?oe.localeCompare(ee):ee.localeCompare(oe)}),Q(W)}Q(W),L.appendChild(H);let X=document.createElement("div");return X.style.overflowY="auto",X.style.maxHeight="400px",X.style.margin="0",X.style.padding="0",X.style.boxSizing="border-box",X.style.overflowX="hidden",X.appendChild(L),setTimeout(()=>{const K=L.offsetWidth+20,Z=X.offsetWidth;K>Z?X.style.overflowX="scroll":(X.style.width=`${K}px`,X.style.overflowX="hidden")},0),X}function l$4($){let N=Array.from(new Set($.features.filter(M=>M!=null).filter(M=>M?.geometry!==null).map(M=>M?.geometry?.type))).filter(M=>M!=null),k=[];return(N.indexOf("Polygon")!==-1||N.indexOf("MultiPolygon")!==-1)&&k.push(3),(N.indexOf("LineString")!==-1||N.indexOf("MultiLineString")!==-1)&&k.push(2),(N.indexOf("Point")!==-1||N.indexOf("MultiPoint")!==-1)&&k.push(1),k.length==1?k[0]:-1}let o$3=null;async function n$5(){return o$3||(o$3=await e(),console.log("GEOS loaded!")),o$3}async function V($){const N=(new Blob([JSON.stringify($,null,2)],{type:"application/json"}).size/1024).toFixed(0),k=$.features.map(U=>U.geometry.coordinates).flat(4).filter(U=>U!==void 0).length/2,M=new Map([[1,"point"],[2,"line"],[3,"poly"]]),L=l$4($),R=await n$5();let I=[];return $.features.forEach((U,H)=>{if(a$3(U?.geometry))I.push({index:H,isValid:0,reason:"empty"});else{const W=geojsonToGeosGeom(U,R);R.GEOSisEmpty(W)?I.push({index:H,isValid:0,reason:"empty"}):I.push({index:H,isValid:R.GEOSisValid(W),reason:R.GEOSisValidReason(W)}),R.GEOSFree(W)}}),I=I.filter(U=>U.isValid==0),I=I.length==0?"Valid Geometries":I,{type:M.get(L),geometries:l$5($),diagnostic:I,properties:[...new Set($?.features.map(U=>Object.keys(U?.properties)).flat())],weight:"~"+N+" KO",nodes:k}}function u$6($,{mutatebydefault:N=!1}={}){return structuredClone($)}function c$4($){let N="",k,M;return c$5($)?(N="FeatureCollection",k=L=>u$5(L),M=L=>L):h$5($)?(N="Features",k=L=>u$5({type:"FeatureCollection",features:L}),M=L=>L.features):g$6($)?(N="Feature",k=L=>u$5({type:"FeatureCollection",features:[L]}),M=L=>L.features.length==1?L.features[0]:L.features):w$4($)?(N="Geometries",k=L=>u$5({type:"FeatureCollection",features:L.map(R=>({type:"Feature",properties:{},geometry:R}))}),M=L=>L.features.map(R=>R.geometry)):P$1($)?(N="Geometry",k=L=>u$5({type:"FeatureCollection",features:[{type:"Feature",properties:{},geometry:L}]}),M=L=>L.features.length==1?L.features[0].geometry:L.features.map(R=>R.geometry)):(N=void 0,k=L=>u$5(L),M=L=>u$5(L)),{type:N,import:k,export:M}}function u$5($){return JSON.parse(JSON.stringify($))}function r$1($){let N=Array.from(new Set($.features.map(M=>M.geometry.type))),k=[];return(N.indexOf("Polygon")!==-1||N.indexOf("MultiPolygon")!==-1)&&k.push(3),(N.indexOf("LineString")!==-1||N.indexOf("MultiLineString")!==-1)&&k.push(2),(N.indexOf("Point")!==-1||N.indexOf("MultiPoint")!==-1)&&k.push(1),{dimension:k.length==1?k[0]:-1,types:N}}function h$4($){const N=c$4($);let k=N.import($),M=[];k.features.forEach(I=>{M.push(n$4(I))});const L=Object.keys(k).filter(I=>I!="features"),R={};return L.forEach(I=>{R[I]=k[I]}),R.features=M.flat(),N.export(R)}function n$4($){let N=[];$?.geometry?.type?.includes("Multi")?$?.geometry?.coordinates.forEach(M=>{N.push({type:"Feature",properties:$?.properties,geometry:{type:$?.geometry?.type.replace("Multi",""),coordinates:M}})}):N.push({...$});const k=geoArea($);return N.forEach(M=>M.__share=geoArea(M)/k),N}const m$3=Object.assign({},{topology,merge});function C$1($,{id:N=null}={}){const k=c$4($);let M=k.import($),L,R=r$1(M).dimension;if(N!=null&&N!=null){let I=Array.from(new Set(M.features.map(H=>H.properties[N]))),U=[];I.forEach(H=>{let W={type:"FeatureCollection",features:M.features.filter(Y=>Y.properties[N]==H)},Q;if(R==3){let Y=m$3.topology({foo:W});Q=m$3.merge(Y,Y.objects.foo.geometries)}R==2&&(Q={type:"MultiLineString",coordinates:h$4(W).features.map(Y=>Y.geometry.coordinates)}),R==1&&(Q={type:"MultiPoint",coordinates:h$4(W).features.map(Y=>Y.geometry.coordinates)}),U.push({type:"Feature",properties:{id:H},geometry:Q})}),L={type:"FeatureCollection",features:U}}else{let I;if(R==3){let U=m$3.topology({foo:M});I=m$3.merge(U,U.objects.foo.geometries)}R==2&&(I={type:"MultiLineString",coordinates:h$4(M).features.map(U=>U.geometry.coordinates)}),R==1&&(I={type:"MultiPoint",coordinates:h$4(M).features.map(U=>U.geometry.coordinates)}),L={type:"FeatureCollection",features:[{type:"Feature",properties:{},geometry:I}]}}return L.name="aggregate",k.export(L)}const i$6=Object.assign({},{sum,min,max,mode,median,mean,variance,deviation});function q$2($,{by:N,keys:k,operators:M,mutate:L=!1}={}){let R=$;if(f$6(R)&&N!==void 0){L||(R=JSON.parse(JSON.stringify($)));const I=k||[...new Set(R?.features.map(Y=>Object.keys(Y?.properties)).flat())].filter(Y=>Y!==N),U=M||Array(I.length).fill("all"),H=new Map(I.map((Y,X)=>[Y,typeof U[X]=="function"?U[X]:b$3(U[X])])),W=o$2([...new Set(R?.features.map(Y=>Y?.properties[N]))]);let Q=[];W.forEach(Y=>{const X=R?.features.filter(Z=>Z?.properties[N]==Y),K={[N]:Y};I.forEach(Z=>{K[Z]=H.get(Z)(X.map(te=>te?.properties[Z]))}),Q.push({type:"Feature",properties:K,geometry:C$1({features:X},{id:Y}).features[0].geometry})}),R.features=Q}else if(p$6(R)&&N!==void 0){const I=k||[...new Set(R.map(Y=>Object.keys(Y)).flat())].filter(Y=>Y!==N),U=M||Array(I.length).fill("all"),H=new Map(I.map((Y,X)=>[Y,typeof U[X]=="function"?U[X]:b$3(U[X])])),W=o$2([...new Set(R.map(Y=>Y[N]))]);let Q=[];W.forEach(Y=>{const X=R.filter(Z=>Z[N]==Y),K={[N]:Y};I.forEach(Z=>{K[Z]=H.get(Z)(X.map(te=>te[Z]))}),Q.push(K)}),R=Q,L&&$.splice(0,$.length,...R)}return R}function b$3($){switch($){case"all":return function(N){return N};case"count":return function(N){return N.length};case"sum":return function(N){return i$6.sum(o$2(N.map(k=>parseFloat(k))))};case"min":return function(N){return i$6.min(o$2(N.map(k=>parseFloat(k))))};case"max":return function(N){return i$6.max(o$2(N.map(k=>parseFloat(k))))};case"mode":return function(N){return i$6.mode(o$2(N.map(k=>parseFloat(k))))};case"median":return function(N){return i$6.median(o$2(N.map(k=>parseFloat(k))))};case"mean":return function(N){return i$6.mean(o$2(N.map(k=>parseFloat(k))))};case"first":return function(N){return o$2(N)[0]};case"last":return function(N){return o$2(N).at(-1)};case"variance":return function(N){return i$6.variance(o$2(N.map(k=>parseFloat(k))))};case"deviation":return function(N){return i$6.deviation(o$2(N.map(k=>parseFloat(k))))};default:return arr}}function o$2($){return $.filter(N=>!["  "," ","",void 0,null,NaN,1/0,-1/0].includes(N))}function a$2($,{key:N,mutate:k=!1}={}){let M=$;if(f$6(M)){k||(M=JSON.parse(JSON.stringify($)));const L=[...new Set(M.features.map(I=>I?.properties[N]))];let R=[];L.forEach(I=>{R.push(M.features.find(U=>U?.properties[N]==I))}),M.features=R}else if(p$6(M)){const L=[...new Set(M.map(I=>I[N]))];let R=[];L.forEach(I=>{R.push(M.find(U=>U[N]==I))}),M=R,k&&$.splice(0,$.length,...M)}return M}function n$3($,{mutate:N=!1}={}){let k;if(N?k=$:k=structuredClone($),f$6(k))return k?.features.map(M=>M?.properties);if(p$6(k))return k}function a$1($,{fillkeys:N=!0}={}){if($.every(k=>f$6(k))){let k=JSON.parse(JSON.stringify($.map(M=>M.features).flat()));if(N){let M=[...new Set(k.map(L=>Object.keys(L.properties)).flat())];k.forEach(L=>{M.forEach(R=>{R in L.properties||(L.properties[R]=void 0)})})}return{type:"FeatureCollection",features:k}}else if($.every(k=>p$6(k))){let k=JSON.parse(JSON.stringify($.flat()));if(N){let M=[...new Set(k.map(L=>Object.keys(L)).flat())];k=k.map(L=>Object.fromEntries(M.map(R=>[R,L[R]])))}return k}}function E$2($,{ids:N,merge:k=!1,emptygeom:M=!0,all:L=!0,fillkeys:R=!0}={}){if(N==null)return a$1($);{if($=$.map(U=>f$6(U)?structuredClone(U.features.map(H=>({...H?.properties,"#geometry#":H.geometry}))):structuredClone(U)),typeof N=="string"&&(N=Array($.length).fill(N)),!k){let U=[];$.forEach(W=>{U.push([...new Set(W.map(Q=>Object.keys(Q)).flat())])});let H=g$5(U);N=N.map((W,Q)=>[W,H[Q][U[Q].indexOf(N[Q])]]).map(W=>W[1]),$=O$2($,H)}let I=$[0];for(let U=1;U<$.length;U++)I=w$2(I,$[U],N[0],N[U],L);if(R){let U=[...new Set(I.map(H=>Object.keys(H)).flat())];I=I.map(H=>Object.fromEntries(U.map(W=>[W,H[W]])))}if([...new Set(I.map(U=>Object.keys(U)).flat())].includes("#geometry#")){M||(I=I.filter(H=>H["#geometry#"]!==void 0));const U=h$3(I,"#geometry#");I={type:"FeatureCollection",features:I.map((H,W)=>({type:"Feature",properties:U[W],geometry:H["#geometry#"]}))}}return I}}function g$5($){const N=new Map;return $.map(k=>k.map(M=>{if(M==="#geometry#")return M;const L="_".repeat(N.get(M)||0);return N.set(M,(N.get(M)||0)+1),L+M}))}function O$2($,N){return $.map((k,M)=>k.map(L=>{let R={},I=N[M];return Object.keys(L).forEach((U,H)=>{let W=I[H]||U;R[W]=L[U]}),R}))}function w$2($,N,k,M,L){const R=$.map(I=>{const U=N.find(H=>{const W=I[k],Q=H[M];return!i$5(W)&&!i$5(Q)&&W===Q});return U?{...I,...U}:{...I}});return L&&N.forEach(I=>{const U=I[M];$.some(H=>{const W=H[k];return!i$5(W)&&!i$5(U)&&W===U})||R.push({...I})}),R}function h$3($,N){return $.map(k=>Object.fromEntries(Object.entries(k).filter(([M])=>!N.includes(M))))}function i$5($){return $==null||$===""}const p$5=Object.assign({},{autoType});function j($,{mutate:N=!1}={}){let k=$;return f$6(k)?(N||(k=JSON.parse(JSON.stringify($))),k.features=k.features.map(M=>({...M,properties:p$5.autoType(Object.fromEntries(Object.entries(M.properties).map(([L,R])=>[L,String(R)])))}))):p$6(k)&&(k=k.map(M=>p$5.autoType(Object.fromEntries(Object.entries(M).map(([L,R])=>[L,String(R)])))),N&&$.splice(0,$.length,...k)),k}const n$2=Object.assign({},{descending,ascending,autoType});function b$2($,{key:N,nb:k=6,mutate:M=!1}={}){let L=$;if(f$6(L)){M||(L=JSON.parse(JSON.stringify($)));let R=[...L.features];if(N!=null){R=R.filter(U=>U.properties[N]!="").filter(U=>U.properties[N]!=null).filter(U=>U.properties[N]!=null).filter(U=>U.properties[N]!=1/0).filter(U=>U.properties[N]!=-1/0).filter(U=>U.properties[N]!=NaN);const I=i$7(L,N)?n$2.descending:n$2.ascending;R=R.sort((U,H)=>I(n$2.autoType([String(U.properties[N])])[0],n$2.autoType([String(H.properties[N])])[0]))}L.features=R.slice(0,k)}else if(p$6(L)){if(N!=null){L=L.filter(I=>I[N]!="").filter(I=>I[N]!=null).filter(I=>I[N]!=null).filter(I=>I[N]!=1/0).filter(I=>I[N]!=-1/0).filter(I=>I[N]!=NaN);const R=u$7(L,N)?n$2.descending:n$2.ascending;L=L.sort((I,U)=>R(n$2.autoType([String(I[N])])[0],n$2.autoType([String(U[N])])[0]))}L=L.slice(0,k),M&&$.splice(0,$.length,...L)}return L}const f$5=Object.assign({},{descending,ascending,autoType});function b$1($,{key:N,nb:k=6,mutate:M=!1}={}){let L=$;if(f$6(L)){M||(L=JSON.parse(JSON.stringify($)));let R=[...L.features];if(N!=null){R=R.filter(U=>U.properties[N]!="").filter(U=>U.properties[N]!=null).filter(U=>U.properties[N]!=null).filter(U=>U.properties[N]!=1/0).filter(U=>U.properties[N]!=-1/0).filter(U=>U.properties[N]!=NaN);const I=i$7(L,N)?f$5.ascending:f$5.descending;R=R.sort((U,H)=>I(f$5.autoType([String(U.properties[N])])[0],f$5.autoType([String(H.properties[N])])[0]))}L.features=R.slice(0,k)}else if(p$6(L)){if(N!=null){L=L.filter(I=>I[N]!="").filter(I=>I[N]!=null).filter(I=>I[N]!=null).filter(I=>I[N]!=1/0).filter(I=>I[N]!=-1/0).filter(I=>I[N]!=NaN);const R=u$7(L,field)?ascending:descending;L=L.sort((I,U)=>R(f$5.autoType([String(I[N])])[0],f$5.autoType([String(U[N])])[0]))}L=L.slice(0,k),M&&$.splice(0,$.length,...L)}return L}async function derive(data,{key="_newkey",value,mutate=!1}={}){let x=data;const operators=/[+\-/*]/;if(f$6(data)){if(mutate||(x=JSON.parse(JSON.stringify(data))),typeof value=="number"||typeof value=="string"&&!operators.test(value))x.features.forEach($=>{$.properties[key]=value});else if(typeof value=="function"){const $=await Promise.all(x.features.map(value));x.features.forEach((N,k)=>{N.properties[key]=$[k]})}else if(typeof value=="string"&&operators.test(value)){const prop=[...new Set(x.features.map($=>$.properties).map($=>Object.keys($)).flat())],newprop=prop.map($=>`d.properties['${$}']`),functrsing="d => "+prop.reduce(($,N,k)=>$.replace(new RegExp(N,"g"),newprop[k]),value),values=await Promise.all(x.features.map(eval(functrsing)));x.features.forEach(($,N)=>{$.properties[key]=values[N]})}}else if(p$6(data)){if(typeof value=="number"||typeof value=="string"&&!operators.test(value))x.forEach($=>{$[key]=value});else if(typeof value=="function"){const $=await Promise.all(x.map(value));x.forEach((N,k)=>{N[key]=$[k]})}else if(typeof value=="string"&&operators.test(value)){const prop=[...new Set(x.map($=>Object.keys($)).flat())],newprop=prop.map($=>`d['${$}']`),functrsing="d => "+prop.reduce(($,N,k)=>$.replace(new RegExp(N,"g"),newprop[k]),value),values=await Promise.all(x.map(eval(functrsing)));x.forEach(($,N)=>{$[key]=values[N]})}mutate&&data.splice(0,data.length,...x)}return x}function filter(data,{func,mutate=!1}={}){let x=data;if(f$6(data)){if(mutate||(x=JSON.parse(JSON.stringify(data))),typeof func=="function")x.features=x.features.filter(func);else if(typeof func=="string"){const prop=[...new Set(x.features.map($=>$.properties).map($=>Object.keys($)).flat())],newprop=prop.map($=>"d.properties['"+$+"']");func="d => "+replaceEquals(addQuotesIfString(prop.reduce(($,N,k)=>$.replace(new RegExp(N,"g"),newprop[k]),func))),x.features=x.features.filter(eval(func))}}else if(p$6(data)){if(typeof func=="function")x=x.filter(func);else if(typeof func=="string"){const prop=[...new Set(x.map($=>Object.keys($)).flat())],newprop=prop.map($=>"d['"+$+"']"),func="d => "+replaceEquals(addQuotesIfString(prop.reduce(($,N,k)=>$.replace(new RegExp(N,"g"),newprop[k]),func)));x=x.filter(eval(func))}mutate&&data.splice(0,data.length,...x)}return x}function replaceEquals($){return $.replace(new RegExp("(?<![><!])=(?![=])","g"),"==")}function addQuotesIfString($){return $.replace(/([><=!]=?|==)\s*([A-Za-z_]+)/g,(N,k,M)=>`${k} '${M}'`)}function g$4($,{search:N="",replacement:k="",keys:M,mutate:L=!1}={}){let R;return L?R=$:R=JSON.parse(JSON.stringify($)),f$6(R)?R.features.forEach(I=>{l$3(I.properties,N,k,M)}):p$6(R)&&(R.forEach(I=>{l$3(I,N,k,M)}),L&&$.splice(0,$.length,...R)),R}function l$3($,N,k,M){let L=Object.entries($);M!==void 0&&Array.isArray(M)&&(L=L.filter(R=>M.includes(R[0]))),L.forEach(([R,I])=>{typeof I=="string"&&($[R]=I.replaceAll(N,k))})}function a($,{keys:N,rename:k,mutate:M=!1}={}){let L=$;if(f$6(L))if(M||(L=JSON.parse(JSON.stringify($))),k!=null&&Array.isArray(k)&&k.length==N.length){const R=N.map((I,U)=>[I,k[U]]);L.features.forEach(I=>{I.properties=Object.fromEntries(R.map(U=>[U[1],I?.properties[U[0]]]))})}else N!==void 0&&Array.isArray(N)&&L.features.forEach(R=>{R.properties=Object.fromEntries(N.map(I=>[I,R?.properties[I]]))});else if(p$6(L)){if(k!=null&&Array.isArray(k)&&k.length==N.length){const R=N.map((I,U)=>[I,k[U]]);L=L.map(I=>Object.fromEntries(R.map(U=>[U[1],I[U[0]]])))}else N!==void 0&&Array.isArray(N)&&(L=L.map(R=>Object.fromEntries(N.map(I=>[I,R[I]]))));M&&$.splice(0,$.length,...L)}return L}const r=Object.assign({},{descending,ascending,autoType});function x$2($,{key:N,ascending:k=!0,mutate:M=!1}={}){let L=$;const R=["",null,void 0,1/0,-1/0,NaN];if(f$6(L)){if(M||(L=JSON.parse(JSON.stringify($))),N!=null){let I=L.features.filter(W=>!R.includes(W?.properties[N])),U=L.features.filter(W=>R.includes(W?.properties[N]));const H=k?r.ascending:r.descending;I=I.sort((W,Q)=>H(r.autoType([String(W.properties[N])])[0],r.autoType([String(Q.properties[N])])[0])),L.features=[...I,...U]}}else if(p$6(L)){if(N!=null){let I=L.filter(W=>!R.includes(W[N])),U=L.filter(W=>R.includes(W[N]));const H=k?r.ascending:r.descending;I=I.sort((W,Q)=>H(r.autoType([String(W[N])])[0],r.autoType([String(Q[N])])[0])),L=[...I,...U]}M&&$.splice(0,$.length,...L)}return L}const i$4=Object.assign({},{topology,presimplify,quantiz:quantize,quantile,simple:simplify,feature});function h$2($,{k:N=void 0,quantize:k=void 0,arcs:M=15e3}={}){const L=c$4($);let R=L.import($),I=i$4.topology({foo:R}),U=i$4.presimplify(I);return N==null&&(N=M/U.arcs.flat().length,N=N>1?1:N),U=i$4.simple(U,i$4.quantile(U,N)),k&&(U=i$4.quantiz(U,k)),R.features=i$4.feature(U,Object.keys(U.objects)[0]).features,R.name="simplify",L.export(R)}function f$4($,N,k,M,L){let R=[];if($.forEach(I=>R.push(Object.keys(I))),R=Array.from(new Set(R.flat())),N==null&&(N=["lat","Lat","LAT","Latitude","latitude"].filter(I=>R.includes(I))[0]),k==null&&(k=["lon","Lon","LON","lng","Lng","LNG","Longitude","longitude"].filter(I=>R.includes(I))[0]),M==null&&(M=["coords","Coords","coord","Coords","Coordinates","coordinates","Coordinate","coordinate"].filter(I=>R.includes(I))[0]),N&&k){let I=N,U=k;return{type:"FeatureCollection",features:$.map(H=>({type:"Feature",properties:H,geometry:{type:"Point",coordinates:L?[parseFloat(H[I]),parseFloat(H[U])]:[parseFloat(H[U]),parseFloat(H[I])]}}))}}return M&&{type:"FeatureCollection",features:$.map(I=>({type:"Feature",properties:I,geometry:{type:"Point",coordinates:L?p$4(I[M]):p$4(I[M]).reverse()}}))}}function d$2($,N=","){$=$.replace(/[ ]+/g,"");let k=$.split(N).map(M=>M.replace(",",".")).map(M=>M.replace(/[^\d.-]/g,"")).map(M=>+M);return k.length!=2&&(k=[void 0,void 0]),k}function c$3($){let N=$.match(/\(([^)]+)\)/g);return N===null?[void 0,void 0]:N[0].replace(/\s\s+/g," ").replace("(","").replace(")","").trimStart().trimEnd().split(" ").map(k=>k.replace(",",".")).map(k=>+k)}function p$4($){return $?$.toLowerCase().includes("point")?c$3($):d$2($):null}const g$3=Object.assign({},{feature});function T$1($,{lat:N=void 0,lon:k=void 0,latitude:M=void 0,longitude:L=void 0,coords:R=void 0,coordinates:I=void 0,reverse:U=!1,properties:H=void 0,rename:W=void 0,filter:Q=void 0,mutate:Y=!1}={}){N=N||M,k=k||L,R=R||I;let X;if(Y?X=$:X=JSON.parse(JSON.stringify($)),c$5(X)||(A$1(X)?X=g$3.feature(X,Object.keys(X.objects)[0]):h$5(X)?X={type:"FeatureCollection",features:X}:g$6(X)?X={type:"FeatureCollection",features:[X]}:w$4(X)?X={type:"FeatureCollection",features:X.map(K=>({type:"Feature",properties:{},geometry:K}))}:P$1(X)?X={type:"FeatureCollection",features:[{type:"Feature",properties:{},geometry:X}]}:b$4(X)?X=f$4(X,N,k,R,U):O$3(X)?X={type:"FeatureCollection",features:X.map(K=>({type:"Feature",properties:{},geometry:{type:"Point",coordinates:U?[parseFloat(K[1]),parseFloat(K[0])]:[parseFloat(K[0]),parseFloat(K[1])]}}))}:m$4(X)&&(X={type:"FeatureCollection",features:[{type:"Feature",properties:{},geometry:{type:"Point",coordinates:X}}]})),Q!=null&&typeof Q=="function"&&(X.features=X.features.filter(Q)),H!=null&&Array.isArray(H))if(W!=null&&Array.isArray(W)&&W.length==H.length){const K=H.map((Z,te)=>[Z,W[te]]);X.features.forEach(Z=>{Z.properties=Object.fromEntries(K.map(te=>[te[1],Z?.properties[te[0]]]))})}else X.features.forEach(K=>{K.properties=Object.fromEntries(H.map(Z=>[Z,K?.properties[Z]]))});return X}function n$1($){const N=c$4($);let k=N.import($);return k=geoStitch(k),k.name="stitch",N.export(k)}function u$4($){const N=c$4($);let k=N.import($),M=[];return k.features.forEach(L=>{a$3(L.geometry)||M.push(L)}),k.features=M,N.export(k)}function g$2($,{defaultype:N="Point"}={}){const k=c$4($);let M=k.import($),L;switch(l$4(M)){case 1:L="Point";break;case 2:L="LineString";break;case 3:L="Polygon";break;default:L=N}return M.features.map(R=>R.geometry=a$3(R.geometry)?{type:L,coordinates:[]}:R.geometry),k.export(M)}function u$3($){const N=c$4($);let k=N.import($),M=[];k.features.forEach(R=>{let I=R.geometry.coordinates.flat(1/0),U=[];for(let H=0;H<I.length;H=H+2)U.push({type:"Feature",properties:R.properties,geometry:{type:"Point",coordinates:[I[H],I[H+1]]}});M.push(U)});let L={type:"FeatureCollection",name:"nodes",features:M.flat()};return N.export(L)}function s$3($=20){const N=geoCircle().center(M=>M).radius($/4).precision(10),k=[];for(let M=-80;M<=80;M+=$)for(let L=-180;L<180;L+=$)k.push({type:"Feature",properties:{},geometry:{type:"MultiPolygon",coordinates:[N([L,M]).coordinates]}});return{type:"FeatureCollection",features:k}}function o$1(){let $=[];return[["Equator",0],["Tropic of Cancer",23.43656],["Tropic of Capricorn",-23.43636],["Arctic Circle",66.56345],["Antarctic Circle",-66.56364]].forEach(N=>{$.push({type:"Feature",properties:{name:N[0],latitude:N[1]},geometry:i$3(N[1])})}),{type:"FeatureCollection",features:$}}function i$3($){let N=[],k=-180;for(;k<=180;)N.push([k,$]),k+=2.5;return{type:"MultiLineString",coordinates:[N]}}const q$1=Object.assign({},{geoEquirectangularRaw,geoBounds});function w$1($){const N=c$4($);let k=T($)?[[$[3],$[2]],[$[0],$[1]]]:q$1.geoBounds(N.import($)),M=k[0][0],L=k[0][1],R=k[1][0],I=k[1][1];const U={type:"FeatureCollection",features:[{type:"Feature",properties:{id:1},geometry:{type:"Polygon",coordinates:L===-90?[[[M,I],[R,I]]]:[[[M,L],[M,I],[R+=(R<M)*360,I],[R,L],[M,L]]]}}]};let H=_(q$1.geoEquirectangularRaw,.02)(U);return H.name="bbox",N.export(H)}const _=($,N)=>{const k=Math.PI/180,M=Math.tan(k*N/2)**2,L=function(Q,Y,X,K,Z,te,ne){if(te--){var oe=D(Q,X),ee=$.invert(...oe),re=O$1(ee),se=S$6(re,Y),ae=S$6(re,K),ie=B(re,Y,K),le=ie*(1+.25*Z)*(1+.25*Z)/(M*Z),pe=2*((se-ae)/Z)*((se-ae)/Z);le+pe>1&se+ae>M|se+ae>.25&&(L(Q,Y,oe,re,se,te,ne),ne.push(ee),L(oe,re,X,K,ae,te,ne))}},R=Q=>{let Y=[],X=Q[0],K=$.invert(...X),Z=O$1(K);Y.push(K);for(var te=1,ne=Q.length;te<ne;te++){let oe=Q[te],ee=$.invert(...oe),re=O$1(ee);L(X,Z,oe,re,S$6(Z,re),16,Y),Y.push(ee),X=oe,Z=re}return Y};let I=Q=>$.invert(...Q),U=Q=>Y=>Y.forEach((X,K)=>Y[K]=Q(X)),H,W={Point:Q=>Q.coordinates=I(Q.coordinates),MultiPoint:Q=>U(I)(Q.coordinates),LineString:Q=>Q.coordinates=R(Q.coordinates),Polygon:Q=>U(R)(Q.coordinates),MultiLineString:Q=>U(R)(Q.coordinates),MultiPolygon:Q=>Q.coordinates.forEach(U(R)),Feature:Q=>H(Q.geometry),GeometryCollection:Q=>Q.geometries.forEach(H),FeatureCollection:Q=>Q.features.forEach(H)};return H=Q=>(W[Q.type](Q),Q),function(Q){return Q=JSON.parse(JSON.stringify(Q)),H(Q)}},B=([$,N,k],[M,L,R],[I,U,H])=>{var W=$*((L-N)*(H-k)-(U-N)*(R-k))+N*((R-k)*(I-$)-(H-k)*(M-$))+k*((M-$)*(U-N)-(I-$)*(L-N)),Q=($+I)*($+M)+(N+U)*(N+L)+(k+H)*(k+R);return(W*W+!(Q*Q))/(Q*Q)},D=([$,N],[k,M])=>[.5*($+k),.5*(N+M)],F$2=Math.PI/180,O$1=([$,N])=>[Math.cos(F$2*N)*Math.cos(F$2*$),Math.cos(F$2*N)*Math.sin(F$2*$),Math.sin(F$2*N)],S$6=([$,N,k],[M,L,R])=>{var I=$*(L-N)-(M-$)*N,U=N*(R-k)-(L-N)*k,H=k*(M-$)-(R-k)*$,W=$*(M+$)+N*(L+N)+k*(R+k);return(I*I+U*U+H*H+!(W*W))/(W*W)};function T($){return Array.isArray($)&&$.length===4&&$.every(N=>typeof N=="number"&&!isNaN(N))}const n=Object.assign({},{topology,neighbors,mesh});Object.assign({},j$1);function F$1($,{id:N}={}){const k=c$4($);let M=k.import($);const L=n.topology({d:M});if(typeof N=="string"&&N!==""){const R=[...new Set(M.features.map(H=>H?.properties[N]))].filter(H=>![null,void 0,""].includes(H)),I=n.neighbors(L.objects.d.geometries);let U=[];R.forEach(H=>{let W=I[R.indexOf(H)].map(Q=>({type:"Feature",properties:{id:H.toString()+"|"+R[Q].toString(),i:H,j:R[Q]},geometry:n.mesh(L,L.objects.d,(Y,X)=>Y.properties[N]==H&X.properties[N]==R[Q])}));U.push(W)}),M.features=U.flat()}else M.features=[{type:"Feature",properties:{},geometry:n.mesh(L,Object.entries(L.objects)[0][1],(R,I)=>R!==I)}];return M.name="border",k.export(M)}function l$2($,{precision:N=2}={}){const k=c$4($);let M=k.import($),L=parse(M,N);return k.export(L)}const o=Object.assign({},{geoArea,geoCentroid,geoIdentity,geoPath});function C($,{largest:N=!0,geo:k=!0}={}){const M=c$4($);let L=M.import($),R=o.geoPath(o.geoIdentity());function I(H){var W={},Q=0;return H.geometry.coordinates.forEach(function(Y){var X={type:"Polygon",coordinates:Y},K=k?o.geoArea(X):R.area(X);K>Q&&(Q=K,W=X)}),W}let U=L.features.map(H=>(k?(console.log(H),H.geometry.coordinates=o.geoCentroid(N==!0?H.geometry.type=="Polygon"?H:I(H):H)):H.geometry.coordinates=R.centroid(N==!0?H.geometry.type=="Polygon"?H:I(H):H),H.geometry.type="Point",H));return L.features=U,L.name="centroid",M.export(L)}function m$2($,{simple:N=!0}={}){const k=c$4($);let M=k.import($),L=M?.stream?geoRewindProjection(M,N):M?.type?f$3(M,N):Array.isArray(M)?Array.from(M,R=>m$2(R,N)):M;return k.export(L)}const f$3=($,N)=>d$1($,h$1(N));function h$1($=!0){let N,k;return geoTransform({polygonStart(){this.stream.polygonStart(),k=[]},lineStart(){k?k.push(N=[]):this.stream.lineStart()},lineEnd(){k||this.stream.lineEnd()},point(M,L){k?N.push([M,L]):this.stream.point(M,L)},polygonEnd(){for(let[M,L]of k.entries()){L.push(L[0].slice()),(M?!geoContains({type:"Polygon",coordinates:[L]},k[0][0]):k[1]?!geoContains({type:"Polygon",coordinates:[L]},k[1][0]):$&&geoArea({type:"Polygon",coordinates:[L]})>2*Math.PI)&&L.reverse(),this.stream.lineStart(),L.pop();for(const[R,I]of L)this.stream.point(R,I);this.stream.lineEnd()}this.stream.polygonEnd(),k=null}})}const d$1=function($,N){const k=N.stream;let M;if(!k)throw new Error("invalid projection");switch($&&$.type){case"Feature":M=p$3;break;case"FeatureCollection":M=P;break;default:M=s$2;break}return M($,k)};function P($,N){return{...$,features:$.features.map(k=>p$3(k,N))}}function p$3($,N){return{...$,geometry:s$2($.geometry,N)}}function S$5($,N){return{...$,geometries:$.geometries.map(k=>s$2(k,N))}}function s$2($,N){return $?$.type==="GeometryCollection"?S$5($,N):$.type==="Polygon"||$.type==="MultiPolygon"?E$1($,N):$:null}function E$1($,N){let k=[],M,L;return geoStream($,N({polygonStart(){k.push(M=[])},polygonEnd(){},lineStart(){M.push(L=[])},lineEnd(){L.push(L[0].slice())},point(R,I){L.push([R,I])}})),$.type==="Polygon"&&(k=k[0]),{...$,coordinates:k}}function m$1($,{outer:N=!1}={}){const k=c$4($);let M=k.import($);for(let L=0;L<M.features.length;L++)if(M.features[L].geometry.type==="Polygon")i$2(M.features[L].geometry.coordinates,N);else if(M.features[L].geometry.type==="MultiPolygon")for(let R=0;R<M.features[L].geometry.coordinates.length;R++)i$2(M.features[L].geometry.coordinates[R],N);return k.export(M)}function i$2($,N){if($.length!==0){c$2($[0],N);for(let k=1;k<$.length;k++)c$2($[k],!N)}}function c$2($,N){let k=0,M=0;for(let L=0,R=$.length,I=R-1;L<R;I=L++){const U=($[L][0]-$[I][0])*($[I][1]+$[L][1]),H=k+U;M+=Math.abs(k)>=Math.abs(U)?k-H+U:U-H+k,k=H}k+M>=0!=!!N&&$.reverse()}async function S$4($,{dist:N=1,mutate:k=!1}={}){const M=await n$5(),L=c$4($);let R=L.import($);return R.features.forEach(I=>{if(a$3(I?.geometry))I.geometry=void 0;else{const U=geojsonToGeosGeom(I,M),H=M.GEOSReverse(U,N),W=geosGeomToGeojson(H,M);I.geometry=W,M.GEOSFree(U),M.GEOSFree(H),M.GEOSFree(W)}}),L.export(R)}async function x$1($,{clip:N,reverse:k=!1}={}){if(N){const M=await n$5(),L=c$4($);let R=L.import($);const I=M.GEOSUnaryUnion(geojsonToGeosGeom(c$4(N).import(N),M));let U=[];R.features.forEach(W=>{const Q=geojsonToGeosGeom(W,M),Y=k==!0?M.GEOSDifference(Q,I):M.GEOSIntersection(Q,I),X=geosGeomToGeojson(Y,M);a$3(X)||U.push({type:"Feature",properties:W.properties,geometry:X}),M.GEOSFree(Y)}),M.GEOSFree(I);const H={type:"FeatureCollection",name:"clip",features:U};return H.name="clip",L.export(H)}else return $}function expressiontovaluesinageojson(geojson,input){if(o$4(input))return geojson.features.map($=>input);if(typeof input=="function")return geojson.features.map(input);if(typeof input=="string"){const prop=[...new Set(geojson.features.map($=>Object.keys($.properties)).flat())],newprop=prop.map($=>"d.properties['"+$+"']"),functrsing="d => "+prop.reduce(($,N,k)=>$.replace(new RegExp(N,"g"),newprop[k]),input),values=geojson.features.map(eval(functrsing));return values}}const c$1=Object.assign({},{geoAzimuthalEquidistant,geoCentroid});async function J($,{isProjected:N=!1,quadsegs:k=8,dist:M=0,each:L=!0,rewind:R=!0,removeempty:I=!0}={}){let U;return typeof M=="number"&&L==!1?U=p$2($,{quadsegs:k,isProjected:N,dist:M}):U=O($,{quadsegs:k,isProjected:N,dist:M,rewind:R}),I&&(U=u$4(await U)),U}async function O($,{dist:N,quadsegs:k,isProjected:M,rewind:L}){const R=c$4($);let I=R.import($),U=expressiontovaluesinageojson(I,N),H={type:"FeatureCollection",name:"buffer",features:await Promise.all(I.features.map(async(W,Q)=>await p$2(W,{dist:U[Q],quadsegs:k,isProjected:M})))};return R.export(H)}async function p$2($,{quadsegs:N=8,isProjected:k=!1,dist:M=0}={}){const L=await n$5(),R=c$4($);let I=R.import($),U;k||(M=M*1e3,U=z(I),I=A(I,U));const H=geojsonToGeosGeom(I,L),W=L.GEOSBuffer(H,M,N);let Q={type:"FeatureCollection",features:[{type:"Feature",properties:I.features.length==1?I.features[0].properties:{},geometry:geosGeomToGeojson(W,L)}]};return L.GEOSFree(H),L.GEOSFree(W),k||(Q=q(Q,U)),Q.name="buffer",m$2&&!a$3(Q.features[0].geometry)&&(Q=m$2(Q,{simple:!0})),R.export(Q)}const S$3=63710088e-1;function z($){var N=c$1.geoCentroid($),k=[-N[0],-N[1]];return c$1.geoAzimuthalEquidistant().rotate(k).scale(S$3)}function g$1($,N){return typeof $[0]!="object"?N($):$.map(function(k){return g$1(k,N)})}function y$2($,N){return typeof $[0]!="object"?N.invert($):$.map(function(k){return y$2(k,N)})}function A($,N){return $.features.forEach(k=>k.geometry.coordinates=g$1(k.geometry.coordinates,N)),$}function q($,N){return $.features.forEach(k=>k.geometry.coordinates=y$2(k.geometry.coordinates,N)),$}async function f$2($,{bbox:N=[90,180,-90,-180]}={}){const k=await n$5(),M=c$4($);let L=M.import($);const R=geojsonToGeosGeom(L,k),I=k.GEOSClipByRect(R,N[3],N[2],N[1],N[0]);let U=geosGeomToGeojson(I,k);return k.GEOSFree(R),k.GEOSFree(I),L.features=[{type:"Feature",properties:{},geometry:U}],L.name="clipbyrect",M.export(L)}async function E($){const N=await n$5(),k=c$4($);let M=k.import($);return M.features.forEach(L=>{if(a$3(L?.geometry))L.geometry=void 0;else{const R=geojsonToGeosGeom(L,N);if(N.GEOSisValid(R)!=1){const I=N.GEOSMakeValid(R);L.geometry=geosGeomToGeojson(I,N),N.GEOSFree(R),N.GEOSFree(I)}}}),k.export(M)}async function S$2($,{dist:N=1,mutate:k=!1}={}){const M=await n$5(),L=c$4($);let R=L.import($);return R.features.forEach(I=>{if(a$3(I?.geometry))I.geometry=void 0;else{const U=geojsonToGeosGeom(I,M),H=M.GEOSDensify(U,N),W=geosGeomToGeojson(H,M);I.geometry=W,M.GEOSFree(U),M.GEOSFree(H),M.GEOSFree(W)}}),R.name="densify",L.export(R)}async function S$1($,{id:N}={}){const k=await n$5(),M=c$4($);let L=M.import($);if(N){const R=[...new Set(L.features.map(U=>U.properties[N]))].filter(U=>!["",void 0,null,NaN,1/0,-1/0].includes(U)),I=new Map(R.map(U=>[U,{type:"FeatureCollection",features:L.features.filter(H=>H.properties[N]==U)}]));L.features=await Promise.all(R.map(async U=>{const H=geojsonToGeosGeom(I.get(U),k),W=k.GEOSUnaryUnion(H);let Q={type:"Feature",properties:{id:U},geometry:geosGeomToGeojson(W,k)};return k.GEOSFree(H),k.GEOSFree(W),Q}))}else{const R=geojsonToGeosGeom(L,k),I=k.GEOSUnaryUnion(R);L.features=[{type:"Feature",properties:{},geometry:geosGeomToGeojson(I,k)}],k.GEOSFree(R),k.GEOSFree(I)}return L.name="union",M.export(L)}async function h($,{ratio:N=0,holes:k=!0}={}){const M=await n$5(),L=c$4($);let R=L.import($);const I=geojsonToGeosGeom(R,M),U=M.GEOSConcaveHull(I,N,k?1:0);let H=geosGeomToGeojson(U,M);return M.GEOSFree(I),M.GEOSFree(U),L.export({type:"FeatureCollection",name:"concavehull",features:[{type:"Feature",properties:{},geometry:H}]})}async function G$1($){const N=await n$5(),k=c$4($);let M=k.import($);const L=geojsonToGeosGeom(M,N),R=N.GEOSConvexHull(L);let I=geosGeomToGeojson(R,N);return N.GEOSFree(L),N.GEOSFree(R),k.export({type:"FeatureCollection",name:"convexhull",features:[{type:"Feature",properties:{},geometry:I}]})}async function G($){const N=await n$5(),k=c$4($);let M=k.import($);const L=geojsonToGeosGeom(M,N),R=N.GEOSEnvelope(L);let I=geosGeomToGeojson(R,N);return N.GEOSFree(L),N.GEOSFree(R),k.export({type:"FeatureCollection",features:[{type:"Feature",name:"envelope",properties:{},geometry:I}]})}async function S($,N){const k=await n$5(),M=geojsonToGeosGeom(T$1($),k),L=geojsonToGeosGeom(T$1(N),k),R=k.GEOSContains(M,L);return k.GEOSFree(M),k.GEOSFree(L),i$1(R)}async function u$2($,N){const k=await n$5(),M=geojsonToGeosGeom(T$1($),k),L=geojsonToGeosGeom(T$1(N),k),R=k.GEOSCovers(M,L);return k.GEOSFree(M),k.GEOSFree(L),i$1(R)}async function m($,N){const k=await n$5(),M=geojsonToGeosGeom(T$1($),k),L=geojsonToGeosGeom(T$1(N),k),R=k.GEOSCrosses(M,L);return k.GEOSFree(M),k.GEOSFree(L),i$1(R)}async function F($,N){const k=await n$5(),M=geojsonToGeosGeom(T$1($),k),L=geojsonToGeosGeom(T$1(N),k),R=k.GEOSDisjoint(M,L);return k.GEOSFree(M),k.GEOSFree(L),i$1(R)}async function f$1($,N){const k=await n$5(),M=geojsonToGeosGeom(T$1($),k),L=geojsonToGeosGeom(T$1(N),k),R=k.GEOSCoveredBy(M,L);return k.GEOSFree(M),k.GEOSFree(L),i$1(R)}async function p$1($,N){const k=await n$5(),M=geojsonToGeosGeom(T$1($),k),L=geojsonToGeosGeom(T$1(N),k),R=k.GEOSEquals(M,L);return k.GEOSFree(M),k.GEOSFree(L),i$1(R)}async function w($,N){const k=await n$5(),M=geojsonToGeosGeom(T$1($),k),L=geojsonToGeosGeom(T$1(N),k),R=k.GEOSIntersects(M,L);return k.GEOSFree(M),k.GEOSFree(L),i$1(R)}async function y$1($,N){const k=await n$5(),M=geojsonToGeosGeom(T$1($),k),L=geojsonToGeosGeom(T$1(N),k),R=k.GEOSOverlaps(M,L);return k.GEOSFree(M),k.GEOSFree(L),i$1(R)}async function l$1($,N){const k=await n$5(),M=geojsonToGeosGeom(T$1($),k),L=geojsonToGeosGeom(T$1(N),k),R=k.GEOSTouches(M,L);return k.GEOSFree(M),k.GEOSFree(L),i$1(R)}async function x($,N){const k=await n$5(),M=geojsonToGeosGeom(T$1($),k),L=geojsonToGeosGeom(T$1(N),k),R=k.GEOSWithin(M,L);return k.GEOSFree(M),k.GEOSFree(L),i$1(R)}async function d($){const N=await n$5(),k=geojsonToGeosGeom(T$1($),N),M=N.GEOSisValid(k);return N.GEOSFree(k),i$1(M)}async function v($){const N=await n$5(),k=geojsonToGeosGeom(T$1($),N),M=N.GEOSisValidReason(k);return N.GEOSFree(k),M}function i$1($){return new Map([[-1,void 0],[0,!1],[1,!0]]).get($)}function y($,N={}){let k=JSON.parse(JSON.stringify($)),M=N.lat||N.latitude,L=N.lon||N.lng||N.longitude,R=N.coords||N.coordinates;(N.sep||N.separator)&&(N.sep||N.separator);let I=!!N.reverse;if(M==null&&L==null&&R==null){let U=["coords","Coords","coord","Coords","Coordinates","coordinates","Coordinate","coordinate"],H=["lat","Lat","LAT","Latitude","latitude"],W=["lon","Lon","LON","lng","Lng","LNG","Longitude","longitude"],Q=[];k.forEach(Y=>Q.push(Object.keys(Y))),Q=Array.from(new Set(Q.flat())),M=H.filter(Y=>Q.includes(Y))[0],L=W.filter(Y=>Q.includes(Y))[0],R=U.filter(Y=>Q.includes(Y))[0]}if(M&&L){let U=I?L:M,H=I?M:L;return{type:"FeatureCollection",features:$.map(W=>({type:"Feature",properties:W,geometry:{type:"Point",coordinates:[+W[H],+W[U]]}}))}}return R&&{type:"FeatureCollection",features:$.map(U=>({type:"Feature",properties:U,geometry:{type:"Point",coordinates:I?f(U[R]):f(U[R]).reverse()}}))}}function p($,N=","){$=$.replace(/[ ]+/g,"");let k=$.split(N).map(M=>M.replace(",",".")).map(M=>M.replace(/[^\d.-]/g,"")).map(M=>+M);return k.length!=2&&(k=[void 0,void 0]),k}function g($){let N=$.match(/\(([^)]+)\)/g);return N===null?[void 0,void 0]:N[0].replace(/\s\s+/g," ").replace("(","").replace(")","").trimStart().trimEnd().split(" ").map(k=>k.replace(",",".")).map(k=>+k)}function f($){return $?$.toLowerCase().includes("point")?g($):p($):null}function s$1({x:$,field:N,expression:k}){let M=[...$.features.map(U=>({...U.properties}))],L=[];$.features.map(U=>U.properties).forEach(U=>{L.push(Object.keys(U))}),L=Array.from(new Set(L.flat())),L.forEach(U=>{k=k.replace(U,`d.${U}`)}),k="d=> "+k;let R=M.map(y$3(k));M.forEach((U,H)=>{U=Object.assign(U,{[N]:R[H]})});let I=JSON.parse(JSON.stringify($));return I.features.map((U,H)=>U.properties={...M[H]}),I}function c({x:$,expression:N}){let k=[...$.features],M=[];$.features.map(R=>R.properties).forEach(R=>{M.push(Object.keys(R))}),M=Array.from(new Set(M.flat())),M.forEach(R=>{N=N.replace(R,`d.properties.${R}`)}),N="d => "+N;let L=JSON.parse(JSON.stringify($));return L.features=k.filter(y$3(N)),L}function s({x:$,field:N}){let k=[...$.features.map(L=>({...L.properties}))];k.forEach(L=>{Array.isArray(N)?N.forEach(R=>delete L[R]):delete L[N]});let M=JSON.parse(JSON.stringify($));return M.features.map((L,R)=>L.properties={...k[R]}),M}function l({x:$,fields:N}){let k=[];$.features.map(L=>L.properties).forEach(L=>{k.push(Object.keys(L))}),k=Array.from(new Set(k.flat()));let M=k.filter(L=>!N.includes(L));return s({x:$,field:M})}function t($){return JSON.parse(JSON.stringify($.features.map(N=>N.properties)))}function i({x:$,field:N,selection:k,inverse:M=!1}){let L=[...$.features];k=Array.isArray(k)?k:[k],M&&(k=Array.from(new Set(L.map(U=>U.properties[N]))).filter(U=>!k.includes(U)));let R=[];k.forEach(U=>{R.push(L.filter(H=>H.properties[N]==U))});let I=JSON.parse(JSON.stringify($));return I.features=R.flat(),I}function u$1({x:$,field:N,nb:k=10}){let M=[...$.features];M=M.filter(R=>R.properties[N]!="").filter(R=>R.properties[N]!=null).filter(R=>R.properties[N]!=null).filter(R=>R.properties[N]!=1/0).filter(R=>R.properties[N]!=-1/0).filter(R=>R.properties[N]!=NaN),M.sort((R,I)=>+I.properties[N]-+R.properties[N]),M=M.slice(0,k);let L=JSON.parse(JSON.stringify($));return L.features=M,L}function u({x:$,field:N,nb:k=10}){let M=[...$.features];M=M.filter(R=>R.properties[N]!="").filter(R=>R.properties[N]!=null).filter(R=>R.properties[N]!=null).filter(R=>R.properties[N]!=1/0).filter(R=>R.properties[N]!=-1/0).filter(R=>R.properties[N]!=NaN),M.sort((R,I)=>+R.properties[N]-+I.properties[N]),M=M.slice(0,k);let L=JSON.parse(JSON.stringify($));return L.features=M,L}let b={add:s$1,select:c,keep:l,remove:s,table:t,subset:i,head:u$1,tail:u};export{C$1 as aggregate,j as autotype,w$1 as bbox,F$1 as border,J as buffer,C as centroid,x$1 as clip,f$2 as clipbyrect,a as columns,a$1 as combine,h as concavehull,S as contains,G$1 as convexhull,y as coords2geo,u$6 as copy,f$1 as coveredby,u$2 as covers,m as crosses,a$2 as dedupe,S$2 as densify,derive,F as disjoint,h$4 as dissolve,G as envelope,p$1 as equals,filter,o$1 as geolines,q$2 as groupby,b$2 as head,w$3 as htmltable,V as info,w as intersects,d as isvalid,v as isvalidreason,t$1 as iterate,E$2 as join,E as makevalid,u$3 as nodes,y$1 as overlaps,b as properties,u$4 as removeemptygeom,g$4 as replace,g$2 as resolveemptygeom,S$4 as reverse,m$2 as rewind,m$1 as rewind2,l$2 as roundcoordinates,h$2 as simplify,x$2 as sort,n$1 as stitch,n$3 as table,b$1 as tail,s$3 as tissot,T$1 as togeojson,l$1 as touches,S$1 as union,x as within};
